/*
 * Created by 动脑科技-Tim on 17-6-21 下午8:48
 * Copyright (c) 2017. All rights reserved
 *
 * Last modified 17-6-21 下午8:48
 */

package com.example

import com.squareup.kotlinpoet.*
import javax.lang.model.element.TypeElement
import com.squareup.kotlinpoet.TypeName.Companion.asTypeName
import java.util.concurrent.atomic.AtomicInteger
import javax.tools.StandardLocation


class ClassBuilder (val typeElement: TypeElement, val methodElement: List<NeedMethod>){

    companion object {
        const val CALLER = "target"
        const val REQUEST = "requestCode"
        const val RESULT = "grantResults"
    }

    //包名
    val PACKAGE_NAME = ELEMENT_UTILS.getPackageOf(typeElement).qualifiedName.toString()

    //类的全类名
    val FULL_NAME = typeElement.qualifiedName.toString()

    //类名
    val CLASS_NAME by lazy {
        var name = FULL_NAME.substring(PACKAGE_NAME.length + 1)
        val index = name.indexOf(".")
        if (index > 0) {
            name = name.substring(index+1, name.length)
        }
        name
    }

    //获得当前类的Type
    val TYPE_TARGET = ELEMENT_UTILS.getTypeElement(FULL_NAME).asType()
    //当前类的ClassName
    val TARGET = TYPE_TARGET.asTypeName()

    //判断当前类是否为Activity等的子类
    val isActivity = TYPE_UTILS.isSubtype(TYPE_TARGET, TYPE_ACTIVITY)
    val isFragment = TYPE_UTILS.isSubtype(TYPE_TARGET, TYPE_FRAGMENT)
    val isSupportFragment = if (null == TYPE_SUPPORT) false else TYPE_UTILS.isSubtype(TYPE_TARGET, TYPE_SUPPORT)

    //请求码
    val currentCode = AtomicInteger(100000)

    //标有onDenieds的元素
    val onDenieds = typeElement.getChildWithAnnotation(OnDeined::class.java)
    val onNeverAsk = typeElement.getChildWithAnnotation(OnNeverAsk::class.java)

    fun brewKotlin() {
        val className = "${CLASS_NAME}Permission"

        val typeSpec = TypeSpec.objectBuilder(className)

        //调用checkSelfPermission的成员名
        var checkCaller = CALLER

        when {
            /*
            * 如果是Fragment或者activity添加target就可以了
            * 调用checkSelfPermission 需要从Fragment获得Activity
            * 调用requestPermissions shouldShowRequestPermissionRationale 可以使用Fragment
            * */
            isSupportFragment || isFragment || isActivity -> {
                if (!isActivity)
                    checkCaller = "$CALLER.activity"
            }
            else -> {
                throw Exception("checkSelfPermission should only call by Activity or Fragment")
            }
        }

        //回调请求结果
        val requestResult = FunSpec.builder("onRequestPermissionsResult")
                .addParameter(CALLER,TARGET)
                .addParameter(REQUEST,Int::class)
                .addParameter(RESULT, IntArray::class)
                .addKdoc("Please call this method in $CLASS_NAME#onRequestPermissionsResult")

        val resultBlock = CodeBlock.builder()
                .beginControlFlow("when($REQUEST)")
        methodElement.forEach {
            need ->
            //target中对应的方法
            val invokeOriginal = "$CALLER.${need.methodName}()"
            val (propertyPermission, propertyRequest) = addProperties(need, typeSpec)
            addPermissionMethod(need, typeSpec, propertyPermission, propertyRequest, checkCaller, invokeOriginal)
            addRequestResult(need, resultBlock, propertyPermission, propertyRequest, invokeOriginal)
        }
        resultBlock.endControlFlow()
        typeSpec.addFun(requestResult.addCode(resultBlock.build()).build())

        FILER_UTILS.createResource( StandardLocation.SOURCE_OUTPUT, PACKAGE_NAME, "$className.kt")
                .openWriter()
                .use {
                    with(KotlinFile.builder(PACKAGE_NAME,className)){
                        addType(typeSpec.build())
                        addFileComment("generated by Kapt , Do not modify!")
                        build()
                    }.writeTo(it)
                }
    }

    fun addProperties(need:NeedMethod, typeSpec: TypeSpec.Builder):Array<String> {
        //创建属性 值为方法需要权限的数组
        val propertyPermission = "PERMISSION_${need.methodName.toUpperCase()}"
        //值为方法 请求码
        val propertyRequest = "REQUEST_${need.methodName.toUpperCase()}"
        val permissionStr = need.permissionName.joinToString("\",\"")

        typeSpec.addProperties(
                listOf(PropertySpec
                        .builder(propertyPermission, STRINGARRAY, KModifier.PRIVATE)
                        .initializer("arrayOf(\"$permissionStr\")")
                        .addKdoc("from $CLASS_NAME#${need.methodName}")
                        .build(),
                        PropertySpec
                                .builder(propertyRequest, Int::class, KModifier.PRIVATE)
                                .addKdoc("request $CLASS_NAME#${need.methodName} needs permission")
                                .initializer("${currentCode.getAndIncrement()}")
                                .build()
                )
        )
        return arrayOf(propertyPermission,propertyRequest)
    }

    //调用此方法来替代被NeedPermission注解的方法
    fun addPermissionMethod(need: NeedMethod, typeSpec: TypeSpec.Builder, propertyPermission:String,
                            propertyRequest:String, checkCaller:String, invokeOriginal:String) {

        val builder = FunSpec.builder("${need.methodName}").run {
            addParameter(CALLER, TARGET)
            //加入权限判断代码
            addCode(CodeBlock.builder()
            //需要使用%T转义，这样才会自动导包
                    //判断版本号是否大于23api
                    //挖坑 --.beginControlFlow("if (%T.VERSION.SDK_INT) >= %T.VERSION_CODES.M", BUILD, BUILD)
                    .beginControlFlow("if (%T.VERSION.SDK_INT >= %T.VERSION_CODES.M)", BUILD, BUILD)
                    //未获取权限的列表
                    .addStatement(" val list = $propertyPermission.filter {$checkCaller.checkSelfPermission(it) == %T.PERMISSION_DENIED}", PACKAGEMANAGER)
                    .beginControlFlow("if(list.isEmpty())")
                    .addStatement(invokeOriginal)
                    .nextControlFlow("else")
                    //请求权限
                    .addStatement("$CALLER.requestPermissions(list.toTypedArray(),$propertyRequest)")
                    .endControlFlow()
                    .nextControlFlow("else")
                    .addStatement(invokeOriginal)
                    .endControlFlow()
                    .build()
            )
            addKdoc("Please call this method replace $CLASS_NAME#${need.methodName}")
        }
        typeSpec.addFun(builder.build())
    }

    fun addRequestResult(need: NeedMethod, resultBlock: CodeBlock.Builder, propertyPermission: String,
                         propertyRequest: String, invokeOriginal: String) {
        val onDenied = findOnDenied(need)
        val onNeverAsk = findOnNeverAsk(need)

        resultBlock.beginControlFlow("$propertyRequest -> ")
        resultBlock.beginControlFlow("if($RESULT.all { it == PackageManager.PERMISSION_GRANTED})")
        resultBlock.addStatement(invokeOriginal)
        resultBlock.nextControlFlow("else")
        resultBlock.beginControlFlow("if ($propertyPermission.all {$CALLER.shouldShowRequestPermissionRationale(it)})")
        // 这里回调请求失败
        if (onDenied != null) {
            resultBlock.addStatement("$CALLER.${onDenied.simpleName()}()")
        }
        resultBlock.nextControlFlow("else")
        //这里回调不再询问
        if (onNeverAsk != null) {
            resultBlock.addStatement("$CALLER.${onNeverAsk.simpleName()}()")
        }

        resultBlock.endControlFlow()
        resultBlock.endControlFlow()
        resultBlock.endControlFlow()
    }
}